# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/rpn/07_matcher.ipynb.

# %% auto 0
__all__ = ['Matcher', 'ATSSMatcher3D']

# %% ../../nbs/rpn/07_matcher.ipynb 0
from torch import Tensor
from typing import List, Union
import torch
from ..layers import nonzero_tuple
from ..structures import pairwise_iou_3d, Boxes3D

class Matcher:

    def __init__(
        self, thresholds: List[float], labels: List[int] = [0, -1, 1], allow_low_quality_matches: bool = False
    ):

        """
        Args:
            thresholds (list): a list of thresholds used to stratify predictions
                into levels.
            labels (list): a list of values to label predictions belonging at
                each level. A label can be one of {-1, 0, 1} signifying
                {ignore, negative class, positive class}, respectively.
            allow_low_quality_matches (bool): if True, produce additional matches
                for predictions with maximum match quality lower than high_threshold.
                See set_low_quality_matches_ for more details.

            For example,
                thresholds = [0.3, 0.5]
                labels = [0, -1, 1]
                All predictions with iou < 0.3 will be marked with 0 and
                thus will be considered as false positives while training.
                All predictions with 0.3 <= iou < 0.5 will be marked with -1 and
                thus will be ignored.
                All predictions with 0.5 <= iou will be marked with 1 and                
        """

        thresholds = thresholds[:]
        assert thresholds[0] > 0
        thresholds.insert(0, -float("inf"))
        thresholds.append(float("inf")) 

        assert all([low <= high for (low, high) in zip(thresholds[:-1], thresholds[1:])])
        assert all([l in [-1, 0, 1] for l in labels])
        assert len(labels) == len(thresholds) - 1

        self.thresholds = thresholds
        self.labels = labels
        self.allow_low_quality_matches = allow_low_quality_matches

    def __call__(self, match_quality_matrix: Tensor):

        """
        Args:
            match_quality_matrix (Tensor[float]): an MxN tensor, containing the
                pairwise quality between M ground-truth elements and N predicted
                elements. All elements must be >= 0 (due to the us of `torch.nonzero`
                for selecting indices in :meth:`set_low_quality_matches_`).

        Returns:
            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched
                ground-truth index in [0, M)
            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates
                whether a prediction is a true or false positive or ignored
        """

        assert match_quality_matrix.dim() == 2
        if match_quality_matrix.numel() == 0:
            default_matches = match_quality_matrix.new_full(
                (match_quality_matrix.size(1),), 0, dtype=torch.int64
            )

            default_match_labels = match_quality_matrix.new_full(
                (match_quality_matrix.size(1),), self.labels[0], dtype=torch.int8
            )

            return default_matches, default_match_labels

        assert torch.all(match_quality_matrix >= 0)

        matched_vals, matches = match_quality_matrix.max(dim=0)
        match_labels = matches.new_full(matches.size(), 1, dtype=torch.int8)

        for l, low, high in zip(self.labels, self.thresholds[:-1], self.thresholds[1:]):
            low_high = (matched_vals >= low) & (matched_vals < high) # Stratify labels
            match_labels[low_high] = l

        # print(f"Labels after matching - ", torch.unique(match_labels, return_counts=True))

        if self.allow_low_quality_matches:
            self.set_low_quality_matches_(match_labels, match_quality_matrix)

        return matches, match_labels

    def set_low_quality_matches_(self, match_labels, match_quality_matrix):

        """
        Produce additional matches for predictions that have only low-quality matches.
        Specifically, for each ground-truth G find the set of predictions that have
        maximum overlap with it (including ties); for each prediction in that set, if
        it is unmatched, then match it to the ground-truth G.

        This function implements the RPN assignment case (i) in Sec. 3.1.2 of
        :paper:`Faster R-CNN`.
        """

        highest_quality_foreach_gt, _ = match_quality_matrix.max(dim=1)
        _, pred_inds_with_highest_quality = nonzero_tuple(
            match_quality_matrix == highest_quality_foreach_gt[:, None]
        )

        match_labels[pred_inds_with_highest_quality] = 1


# %% ../../nbs/rpn/07_matcher.ipynb 1
class ATSSMatcher3D:
    def __init__(self, topk: int = 12, allow_low_quality_matches: bool = True, center_in_gt: bool = True):
        self.topk = topk
        self.allow_low_quality_matches = allow_low_quality_matches
        self.center_in_gt = center_in_gt

    def __call__(self, gt_bboxes: torch.Tensor, anchors: Union[torch.Tensor, List[torch.Tensor]]):
        """
        Args:
            gt_bboxes: Tensor of shape (G, 6) in [z1, y1, x1, z2, y2, x2] format.
            anchors: Either a single Tensor of shape (A, 6) or a list/tuple of
                per-level anchor tensors, each shaped (Ai, 6) in the same format.

        Returns:
            matched_idxs: Long tensor of shape (A,) with GT indices per anchor.
            match_labels: Int8 tensor of shape (A,) with labels in {0, 1}.
        """
        if isinstance(anchors, (list, tuple)):
            anchors_per_level = anchors
            if len(anchors_per_level) == 0:
                anchors_flat = torch.empty((0, 6), device=gt_bboxes.device)
                num_anchors_per_level = []
            else:
                anchors_flat = torch.cat(anchors_per_level, dim=0)
                num_anchors_per_level = [a.shape[0] for a in anchors_per_level]
        else:
            anchors_flat = anchors
            anchors_per_level = [anchors_flat]
            num_anchors_per_level = [anchors_flat.shape[0]]

        num_anchors = anchors_flat.shape[0]
        if num_anchors == 0:
            return (
                torch.zeros((0,), dtype=torch.int64, device=gt_bboxes.device),
                torch.zeros((0,), dtype=torch.int8, device=gt_bboxes.device),
            )

        if gt_bboxes.numel() == 0:
            return (
                torch.zeros(num_anchors, dtype=torch.int64, device=anchors_flat.device),
                torch.zeros(num_anchors, dtype=torch.int8, device=anchors_flat.device),
            )

        match_quality_matrix = pairwise_iou_3d(Boxes3D(gt_bboxes), Boxes3D(anchors_flat))

        anchor_centers = 0.5 * (anchors_flat[:, :3] + anchors_flat[:, 3:])
        gt_centers = 0.5 * (gt_bboxes[:, :3] + gt_bboxes[:, 3:])


        candidate_idxs_per_gt = []
        start = 0
        for level_size in num_anchors_per_level:
            if level_size == 0:
                candidate_idxs_per_gt.append(
                    torch.empty((gt_bboxes.size(0), 0), dtype=torch.long, device=anchors_flat.device)
                )
                continue

            anchors_level = anchor_centers[start:start + level_size]
            dist = (gt_centers[:, None, :] - anchors_level[None, :, :]).pow(2).sum(dim=-1)
            k = min(self.topk, level_size)
            _, topk_idx = torch.topk(dist, k, dim=1, largest=False)
            candidate_idxs_per_gt.append(topk_idx + start)
            start += level_size

        candidate_idxs = (
            torch.cat(candidate_idxs_per_gt, dim=1)
            if len(candidate_idxs_per_gt) > 0
            else torch.empty((gt_bboxes.size(0), 0), dtype=torch.long, device=anchors_flat.device)
        )

        if candidate_idxs.numel() == 0:
            matched_vals, matched_idxs = match_quality_matrix.max(dim=0)
            match_labels = torch.zeros_like(matched_idxs, dtype=torch.int8)
            if self.allow_low_quality_matches:
                self._set_low_quality_matches(match_labels, match_quality_matrix)
            return matched_idxs, match_labels

        candidate_ious = torch.gather(match_quality_matrix, 1, candidate_idxs)
        iou_mean = candidate_ious.mean(dim=1)
        iou_std = candidate_ious.std(dim=1, unbiased=False)
        iou_thresholds = iou_mean + iou_std

        rows = torch.arange(gt_bboxes.size(0), device=anchors_flat.device)[:, None].expand_as(candidate_idxs)
        candidate_iou_vals = match_quality_matrix[rows, candidate_idxs]
        threshold_mask = candidate_iou_vals >= iou_thresholds[:, None]

        if self.center_in_gt:
            inside = (
                (anchor_centers[:, 0][None, :] >= gt_bboxes[:, 0][:, None])
                & (anchor_centers[:, 0][None, :] <= gt_bboxes[:, 3][:, None])
                & (anchor_centers[:, 1][None, :] >= gt_bboxes[:, 1][:, None])
                & (anchor_centers[:, 1][None, :] <= gt_bboxes[:, 4][:, None])
                & (anchor_centers[:, 2][None, :] >= gt_bboxes[:, 2][:, None])
                & (anchor_centers[:, 2][None, :] <= gt_bboxes[:, 5][:, None])
            )
            threshold_mask = threshold_mask & inside[rows, candidate_idxs]

        is_pos = torch.zeros_like(match_quality_matrix, dtype=torch.bool)
        is_pos[rows, candidate_idxs] = threshold_mask

        min_val = torch.finfo(match_quality_matrix.dtype).min
        pos_iou = match_quality_matrix.clone()
        pos_iou[~is_pos] = min_val

        matched_vals, matched_idxs = pos_iou.max(dim=0)
        match_labels = torch.zeros_like(matched_idxs, dtype=torch.int8)
        positive_mask = matched_vals > min_val
        match_labels[positive_mask] = 1

        if self.allow_low_quality_matches:
            self._set_low_quality_matches(match_labels, match_quality_matrix)

        if (~positive_mask).any():
            best_overall = match_quality_matrix.max(dim=0).indices
            matched_idxs = torch.where(positive_mask, matched_idxs, best_overall)

        return matched_idxs, match_labels

    def _set_low_quality_matches(self, match_labels, match_quality_matrix):
        highest_quality_per_gt, _ = match_quality_matrix.max(dim=1)
        gt_inds, pred_inds = torch.nonzero(
            match_quality_matrix == highest_quality_per_gt[:, None],
            as_tuple=True,
        )
        match_labels[pred_inds] = 1
