# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/metrics/20_box_metrics.ipynb.

# %% auto 0
__all__ = ['BoxMetrics3D']

# %% ../../nbs/metrics/20_box_metrics.ipynb 1
import numpy as np
from typing import Iterable, Dict, List, Tuple

class BoxMetrics3D:

    def __init__(
            self,
            iou_thresholds: Iterable[float],
            max_detections: int | None = None,
    ):
        """
        Args:
            iou_thresholds (Iterable[float]): IoU thresholds used for
                AP / AR computation.
            max_detections (int | None): Optional cap on number of
                predictions per sample (after score sorting).
        """

        self.iou_thresholds = tuple(iou_thresholds)
        self.max_detections = max_detections

    @staticmethod
    def iou_3d(
        box: np.ndarray,
        boxes: np.ndarray
    ):
        ix1 = np.maximum(box[0], boxes[:, 0])
        iy1 = np.maximum(box[1], boxes[:, 1])
        iz1 = np.maximum(box[2], boxes[:, 2])

        ix2 = np.minimum(box[3], boxes[:, 3])
        iy2 = np.minimum(box[4], boxes[:, 4])
        iz2 = np.minimum(box[5], boxes[:, 5])

        inter = (
            np.maximum(ix2 - ix1, 0) *
            np.maximum(iy2 - iy1, 0) *
            np.maximum(iz2 - iz1, 0)
        )

        vol_box = np.prod(box[3:] - box[:3])
        vol_boxes = np.prod(boxes[:, 3:] - boxes[:, :3], axis=1)

        union = vol_box + vol_boxes - inter
        return inter / np.maximum(union, 1e-6)
    
    def match_predictions(
            self,
            pred_boxes: np.ndarray,
            pred_scores: np.ndarray,
            gt_boxes: np.ndarray,
            iou_thresh: float,
    ) -> Tuple[np.ndarray, np.ndarray, int]:
        
        order = np.argsort(pred_scores)[::-1]

        if self.max_detections is not None:
            order = order[: self.max_detections]

        pred_boxes = pred_boxes[order]
        pred_scores = pred_scores[order]

        tp = np.zeros(len(pred_boxes))
        fp = np.zeros(len(pred_boxes))
        matched_gt = np.zeros(len(gt_boxes), dtype=bool)

        if len(gt_boxes) == 0:
            fp[:] = 1
            return tp, fp, 0

        for i, pb in enumerate(pred_boxes):
            ious = self.iou_3d(pb, gt_boxes)
            j = np.argmax(ious)

            if ious[j] >= iou_thresh and not matched_gt[j]:
                tp[i] = 1
                matched_gt[j] = True
            else:
                fp[i] = 1

        return tp, fp, len(gt_boxes)
    
    @staticmethod
    def compute_ap(
        tp: np.ndarray,
        fp: np.ndarray,
        num_gt: int
    ):
        
        if num_gt==0:
            return 0.0
        
        tp_cum = np.cumsum(tp)
        fp_cum = np.cumsum(fp)

        recall = tp_cum / num_gt
        precision = tp_cum / np.maximum(tp_cum + fp_cum, 1e-6)

        recall = np.concatenate(([0.0], recall, [1.0]))
        precision = np.concatenate(([0.0], precision, [0.0]))

        for i in range(len(precision) - 1, 0, -1):
            precision[i - 1] = max(precision[i - 1], precision[i])

        idx = np.where(recall[1:] != recall[:-1])[0]
        return float(np.sum(
            (recall[idx + 1] - recall[idx]) * precision[idx + 1]
        ))
    
    @staticmethod
    def compute_ar(
        tp: np.ndarray,
        num_gt: int
    ) -> float:
        
        if num_gt == 0:
            return 0.0
        return float(np.sum(tp) / num_gt)
    
    def __call__(
            self,
            samples: List[Dict[str, np.ndarray]],
    ) -> Dict[str, float | Dict[float, float]]:
        
        """
        Args:
            samples (list[dict]): Dataset predictions & GTs.

        Returns:
            dict containing mAP, mAR, and per-IoU metrics.
        """

        ap_per_iou = {}
        ar_per_iou = {}

        for iou_t in self.iou_thresholds:
            
            all_tp, all_fp = [], []
            total_gt = 0

            for s in samples: # Iterate over each image

                tp, fp, num_gt = self.match_predictions(
                    s["pred_boxes"],
                    s["pred_scores"],
                    s["gt_boxes"],
                    iou_t
                )

                all_tp.append(tp)
                all_fp.append(fp)
                total_gt += num_gt
            
            tp = np.concatenate(all_tp) if all_tp else np.array([])
            fp = np.concatenate(all_fp) if all_fp else np.array([])

            ap_per_iou[iou_t] = self.compute_ap(tp, fp, total_gt)
            ar_per_iou[iou_t] = self.compute_ar(tp, total_gt)

        return {
            "mAP": float(np.mean(list(ap_per_iou.values()))),
            "mAR": float(np.mean(list(ar_per_iou.values()))),
            "AP": ap_per_iou,
            "AR": ar_per_iou
        }